# C_oteraciq
Контроллер итерации для ADAM-6717 + ADAM-6224 (C-программа)
1. Цель проекта

Реализовать внешний контроллер итерации на языке C, работающий на модуле Advantech ADAM-6717, который:

управляет аналоговым выходом AO0 модуля ADAM-6224 по Modbus/TCP;

обеспечивает жёстко стабильную во времени итерацию (линейный профиль напряжения на AO0);

на каждом шаге итерации измеряет все 8 аналоговых входов AI0…AI7 ADAM-6717;

логирует данные в CSV-файл для последующего анализа (Excel, Node-RED, др.);

работает независимо от Node-RED, как отдельное приложение с приоритетом по времени.

Дальнейшая интеграция с Node-RED возможна (через файлы, сокеты, HTTP), но на текущем этапе задача — сделать стабильное, предсказуемое по таймингу измерительное ядро.

2. Аппаратная конфигурация

Контроллер: Advantech ADAM-6717

ОС: Linux (armhf, ядро реального времени)

На нём же установлен Node-RED, но текущая программа — отдельный бинарник.

Модуль аналогового выхода: Advantech ADAM-6224

Протокол: Modbus/TCP

IP: 192.168.2.2 (жёстко зашито в коде; при необходимости — параметризуем)

Порт: 502

Slave ID: 1

Используется канал AO0, диапазон ±5 В.

Модуль аналогового ввода: встроенные AI-каналы ADAM-6717

Используется 8 каналов AI0…AI7.

Работа через библиотеку adamapi (API Advantech).

Сеть и доступ:

ADAM-6717 доступен по IP 192.168.0.214 (SSH, SCP, FTP).

Сборка исполняемого файла — на Windows-ПК, копирование на 6717 по SCP/FTP.

3. Общая архитектура решения

На ПК (Windows) хранится проект (каталог C:\ADAM_BUILD).

Код на C компилируется кросс-компилятором ARM через Docker-контейнер Debian (gcc-arm-linux-gnueabihf, libmodbus-dev:armhf, adamapi).

Результат сборки — бинарный файл adam6224_iter_step_arm для ARM.

Этот бинарник копируется на ADAM-6717 (в /home/root/).

На ADAM-6717 запускается:

./adam6224_iter_step_arm


Программа:

читает параметры итерации из /home/root/iter_params.txt;

выполняет один скан по диапазону (линейный профиль);

на каждом шаге измеряет AI0…AI7;

пишет CSV-лог iter_8ch_YYYYMMDD_HHMMSS.csv.

4. Текущая реализация: adam6224_iter_step.c

Основная программа (однофайловый вариант) делает следующее:

Загрузка параметров итерации из /home/root/iter_params.txt:

start_mV — начальное значение AO0 в мВ;

end_mV — конечное значение AO0 в мВ;

step_mV — шаг по мВ;

period_ms — период одного шага (микрошаг итерации), мс;

settle_ms — время стабилизации после установки AO перед измерением, мс;

pause_ms — дополнительная пауза перед переходом к следующей фазе;

repeats — число циклов (проходов по всем фазам). Значение 0 включает
бесконечный режим до ручной остановки (Ctrl+C). Отрицательные значения
считаются как 1.

Инициализация устройств:

AdamIO_Open → открытие ADAM-6717 (AI-часть).

Отключение автoфильтра, установка режима интеграции high-speed:

AI_SetAutoFilterEnabled(fd, 0x00, 0);

AI_SetIntegrationMode(fd, 0xA0);

modbus_new_tcp + modbus_connect → соединение с ADAM-6224 (AO-часть).

Формирование CSV-файла вида:

iter_8ch_YYYYMMDD_HHMMSS.csv


Заголовок:

cycle;phase;idx;time_ms;iter_mV;iter_V;code_set;ao_V;AI0;AI1;AI2;AI3;AI4;AI5;AI6;AI7

Колонка `cycle` — 1-базовый номер текущего цикла (прохода по всем фазам).


Итерационный цикл (один проход по диапазону):

Вычисляется абсолютное время t_set для каждого шага на основе CLOCK_MONOTONIC + TIMER_ABSTIME:

clock_gettime(CLOCK_MONOTONIC, &t0);

t_set = t0;

для каждого шага t_set += period_ms (в наносекундах);

clock_nanosleep(CLOCK_MONOTONIC, TIMER_ABSTIME, &t_set, NULL);

Это даёт жёстко стабильный период шага, независимый от времени выполнения кода.

На каждом шаге:

В момент t_set:

пересчёт iter_mV → iter_V (В) с насыщением в диапазоне ±5 В;

voltage_to_code(iter_V) → код 0…4095 для AO0;

modbus_write_register(AO0, code_set).

Время измерения:

t_meas = t_set + settle_ms;

clock_nanosleep до t_meas.

Фактическое время:

t_now = CLOCK_MONOTONIC;

time_ms = t_now - t0 в миллисекундах (double).

Измерение всех 8 AI-каналов:

массив float ai[8];

для ch = 0..7:

AI_GetFloatValue(fd, ch, &ai[ch], &status);

если нет ошибки → prev_ai[ch] = ai[ch];

если есть ошибка → ai[ch] = prev_ai[ch]; (используем предыдущее значение, НЕ прерываем программу).

Пересчёт code_set → ao_V через code_to_voltage().

Запись строки в CSV:

cycle;phase;idx;time_ms;iter_mV;iter_V;code_set;ao_V;AI0;...;AI7


Отладочный вывод в stdout:

одна строка: phase=… idx=… AO=… AI=[AI0 ... AI7].

Завершение работы:

закрытие Modbus-соединения;

AdamIO_Close(fd_io);

закрытие CSV-файла.

Рабочий цикл можно корректно остановить вручную через Ctrl+C (SIGINT)
— программа завершит текущий шаг, закроет соединения и CSV-файл.

5. Структура каталога проекта (C:\ADAM_BUILD)

Примерная структура (можно использовать как основу):

C:\ADAM_BUILD\
  adam6224_iter_step.c         // текущий основной файл с логикой итерации 8 каналов
  adam6224_iter_step_arm       // собранный ARM-бинарник (результат сборки)
  adam6224_ao0_test.c          // вспомогательный пример управления AO0
  adam6224_ao0_saw.c           // пример генерации "пилы" на AO0
  adam6717io_example*.c        // примеры работы с ADAM-6717 из SDK
  includes\
      adamapi.h                // заголовок ADAM API
      ...                      // другие заголовки при необходимости
  libs\
      libadamapi.so            // библиотека ADAM API (armhf)
      libmodbus.so.*           // libmodbus (armhf)
  build_adam6224_iter_step.cmd // скрипт сборки через Docker
  iter_params.txt              // параметры итерации для runtime
  README.md                    // (этот файл)

6. Параметры итерации: iter_params.txt

Файл /home/root/iter_params.txt на ADAM-6717 (в репозитории можно хранить эталонный вариант).

Начиная с текущей версии поддерживается массив фаз (до 5 штук за один цикл).
Для каждой фазы задаётся набор:

* `start_mV` / `end_mV` — диапазон в мВ;
* `step_mV` — шаг, знак должен соответствовать направлению;
* `period_ms` — период между микрошагами;
* `settle_ms` — ожидание перед чтением AI;
* `pause_ms` — дополнительная пауза после завершения фазы (может быть 0).

Параметры **без префикса** относятся к первой фазе. Для последующих фаз используются ключи с индексом, например `step2_start_mV`, `step2_period_ms`, `step2_pause_ms`. Допустимы также префиксы `phaseN_`. Количество фаз определяется автоматически по максимальному индексу (либо можно задать `phases=N`, где `N ≤ 5`). Значения по умолчанию для каждой фазы: start = −5000 мВ, end = 5000 мВ, step = 100 мВ, period = 100 мс, settle = 50 мс, pause = 0 мс.

Пример iter_params.txt с пятью фазами (профиль «туда-обратно» разбит на 5 шагов):

```
# 5-шаговый профиль, повторяется бесконечно
repeats=0
phases=5

# Фаза 1: от -5 В до -2.5 В
start_mV=-5000
end_mV=-2500
step_mV=250
period_ms=100
settle_ms=40
pause_ms=100

# Фаза 2: от -2.5 В до 0 В
step2_start_mV=-2500
step2_end_mV=0
step2_step_mV=250
step2_period_ms=100
step2_settle_ms=40
step2_pause_ms=100

# Фаза 3: от 0 В до +2.5 В
step3_start_mV=0
step3_end_mV=2500
step3_step_mV=250
step3_period_ms=100
step3_settle_ms=40
step3_pause_ms=100

# Фаза 4: от +2.5 В до +5 В
step4_start_mV=2500
step4_end_mV=5000
step4_step_mV=250
step4_period_ms=100
step4_settle_ms=40
step4_pause_ms=100

# Фаза 5: возврат от +5 В к -5 В
step5_start_mV=5000
step5_end_mV=-5000
step5_step_mV=-250
step5_period_ms=120
step5_settle_ms=50
step5_pause_ms=200
```

Требования проверяются отдельно для каждой фазы:

* `step_mV ≠ 0`;
* знак `step_mV` должен соответствовать направлению (`start_mV < end_mV → step_mV > 0`, и наоборот);
* `period_ms ≥ 1`, `0 ≤ settle_ms < period_ms`;
* `pause_ms ≥ 0`.

7. Формат CSV-лога

Файл: iter_8ch_YYYYMMDD_HHMMSS.csv

Первая строка — заголовок:

cycle;phase;idx;time_ms;iter_mV;iter_V;code_set;ao_V;AI0;AI1;AI2;AI3;AI4;AI5;AI6;AI7


Далее строки вида:

1;1;0;12.345;-5000;-5.000000;0;-5.000000;0.001234;0.001235;...;0.001240


cycle — 1-базовый номер текущего цикла (прохода по всем фазам);

phase — номер фазы (1-базовый), в которой выполнен микрошаг;

idx — счётчик микрошагов внутри текущей фазы (сбрасывается при переходе к следующей);

time_ms — время с момента старта программы (double, миллисекунды);

iter_mV / iter_V — заданное напряжение по профилю;

code_set — код ЦАП для AO0 (0…4095);

ao_V — пересчитанное напряжение на AO0 из кода;

AI0…AI7 — измеренные значения 8 каналов (Вольты).

8. Сборка через Docker-скрипт

Сборка выполняется из Windows через build_adam6224_iter_step.cmd.

Пример содержимого скрипта:

@echo off
setlocal

cd /d C:\ADAM_BUILD

echo === Начало сборки adam6224_iter_step.c ===

docker run --rm -v "%cd%":/work -w /work debian:11 ^
  bash -lc "dpkg --add-architecture armhf && apt-get update && apt-get install -y gcc-arm-linux-gnueabihf libmodbus-dev:armhf && arm-linux-gnueabihf-gcc -O2 adam6224_iter_step.c -o adam6224_iter_step_arm -I./includes -L./libs -ladamapi -L/usr/arm-linux-gnueabihf/lib -lmodbus"

if errorlevel 1 (
    echo.
    echo *** Ошибка сборки adam6224_iter_step_arm ***
) else (
    echo.
    echo *** Сборка завершена успешно. Бинарник: adam6224_iter_step_arm ***
)

endlocal
pause


Требования:

установлен Docker Desktop;

интернет-доступ для скачивания образа debian:11 и пакетов.

9. Деплой и запуск на ADAM-6717

Сборка на ПК → получение adam6224_iter_step_arm.

Копирование на 6717 (пример через SCP):

scp adam6224_iter_step_arm root@192.168.0.214:/home/root/


SSH на модуль:

ssh root@192.168.0.214


Выдача прав на запуск:

chmod +x adam6224_iter_step_arm


Проверка/создание iter_params.txt в /home/root/.

Запуск:

./adam6224_iter_step_arm


После завершения работы программа создаёт CSV-файл в текущем каталоге (/home/root/).

10. Требования к дальнейшей разработке (для ИИ-инструментов)

При модификации кода и архитектуры сохранять:

Жёсткую временную модель:

использование CLOCK_MONOTONIC;

clock_nanosleep(..., TIMER_ABSTIME, ...) для шага итерации;

period_ms задаёт реальный период шага, который не плавает.

Структуру шагов:

установка AO0 в момент t_set;

измерение AI0…AI7 в окне [t_set + settle_ms; t_set + period_ms).

Формат CSV:

сохранить существующий заголовок и порядок столбцов;

при добавлении новых полей — делать это аккуратно, с описанием.

Простой однонитевой дизайн:

без потоков/многозадачности;

один главный цикл.

Отсутствие динамического выделения памяти:

работать на статических массивах/структурах.

Корректная обработка ошибок:

ошибки Modbus/ADAM не должны по умолчанию “убивать” программу;

для AI-каналов при ошибке чтения использовать предыдущее значение.

11. Планы развития (эти функции пока не реализованы)

Эти пункты можно использовать в качестве задач для дальнейшей разработки:

Повтор итерационных циклов:

параметр repeats (N или бесконечно);

счётчик cycle в CSV и на stdout (дополнительно к текущему столбцу phase).

Профиль “туда-обратно”:

один цикл = start → end → start (треугольник).

Расширение iter_params.txt:

выбор профиля (линейный, треугольный);

количество циклов;

возможно, выбор диапазона каналов (0…7 / подмножество).

Интерфейс управления снаружи:

чтение команд/параметров из файла (командный FIFO);

вариант: TCP/Unix-сокет или HTTP-endpoint для управления запуском/остановкой.

Модульность кода:

выделение модулей:

params.c/params.h — загрузка/валидация параметров;

iter_core.c/iter_core.h — логика итерации;

io_adam.c/io_adam.h — обёртки над ADAM API и Modbus.

12. Минимальный HTTP-сервер для панели оператора

Для чтения последней строки активного CSV и файла уставок можно запустить лёгкий однопоточный HTTP-сервер (без Node-RED) `iter_http_server` на самом ADAM-6717.

- Порт: `8080` (изменяется через константу `LISTEN_PORT` в `iter_http_server.c`).
- Точки входа:
  - `GET /` — служебный ответ с перечислением доступных endpoints.
  - `GET /status` — JSON с последней строкой последнего CSV `iter_8ch_*.csv` в `/home/root/`. Если файлов нет — `{"data_status":"no_data"}`; если строка некорректна — `{"data_status":"invalid"}`.
  - `GET /params` — отдаёт текст `iter_params.txt` из `/home/root/`.

Пример сборки на устройстве (не требуется внешних библиотек):

```
gcc -Wall iter_http_server.c -o iter_http_server
```

Запуск:

```
./iter_http_server
```

Панель оператора на 192.168.0.106 может опрашивать `http://192.168.0.214:8080/status` с нужным периодом без влияния на основной цикл итерации.
